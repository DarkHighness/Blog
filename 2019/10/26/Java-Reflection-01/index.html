<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>谈一谈Java反射 (上) | Twilight Spring</title><meta name="description" content="谈一谈Java反射 (上)"><meta name="keywords" content="Java,Reflection ( 反射 )"><meta name="author" content="Twiliness"><meta name="copyright" content="Twiliness"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://twiliness.xyz/2019/10/26/Java-Reflection-01/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="谈一谈Java反射 (上)"><meta name="twitter:description" content="谈一谈Java反射 (上)"><meta name="twitter:image" content="https://i.loli.net/2019/10/26/LebU96TKxpA27Ev.jpg"><meta property="og:type" content="article"><meta property="og:title" content="谈一谈Java反射 (上)"><meta property="og:url" content="https://twiliness.xyz/2019/10/26/Java-Reflection-01/"><meta property="og:site_name" content="Twilight Spring"><meta property="og:description" content="谈一谈Java反射 (上)"><meta property="og:image" content="https://i.loli.net/2019/10/26/LebU96TKxpA27Ev.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="谈一谈Java反射 (下)" href="https://twiliness.xyz/2019/10/26/Java-Reflection-02/"><link rel="next" title="字符串匹配03 - KMP 算法" href="https://twiliness.xyz/2019/10/07/String-Matching-03-KMP/"><link rel="manifest" href="/img/pwa/manifest.json"><meta name="theme-color" content="#327a77"><meta name="msapplication-TileColor" content="#327a77"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,cookieDomain:"https://twiliness.xyz/",msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},highlight_copy:"true",highlight_lang:"true",highlight_shrink:"true",copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},bookmark:{title:"添加书签",message_prev:"按",message_next:"键将本页加入书签"},runtime_unit:"天",copyright:{languages:{author:"作者: Twiliness",link:"链接: https://twiliness.xyz/2019/10/26/Java-Reflection-01/",source:"来源: Twilight Spring",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},copy_copyright_js:!0}</script></head><body><canvas class="fireworks"></canvas><div id="header"><div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Twilight Spring</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 杂项</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/anime/"><i class="fa-fw fa fa-film"></i><span> 动漫</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-video-camera"></i><span> 图库</span></a></li></ul></div><script>document.body.addEventListener("touchstart",function(){})</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://i.loli.net/2019/09/30/SfN9VwZEWAiDpXO.png" onerror='onerror=null,src="/img/friend_404.gif"'></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 杂项</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/anime/"><i class="fa-fw fa fa-film"></i><span> 动漫</span></a></li><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-video-camera"></i><span> 图库</span></a></li></ul></div><script>document.body.addEventListener("touchstart",function(){})</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#谈一谈java反射-上"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">谈一谈Java反射 (上)</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#从-getmethod-和-getdeclaredmethod-说起"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">从 getMethod 和 getDeclaredMethod 说起</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#继续深入-getmethod0-方法"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">继续深入 - getMethod0 方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#再进一步-getmethodsrecursive-方法"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">再进一步 - getMethodsRecursive 方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#走到底了-privategetdeclaredmethods-方法"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">走到底了 - privateGetDeclaredMethods 方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#回过头来提一提-searchmethod-方法"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">回过头来提一提 - searchMethod 方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#再来看一看-getreflectionfactorycopymethod-方法"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">再来看一看- getReflectionFactory()#copyMethod() 方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#methodinvoke-开始了-从方法调用开始"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">Method#invoke 开始了, 从方法调用开始</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#step-1-检查调用权限"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">Step 1. 检查调用权限</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#step-2获取-methodaccessor-对象"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">Step 2.获取 MethodAccessor 对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#调用-methodaccessorinvoke-对方法进行调用"><span class="toc_mobile_items-number">1.7.3.</span> <span class="toc_mobile_items-text">调用 MethodAccessor#invoke 对方法进行调用</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#慢在哪里"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">慢在哪里?</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drawbacks-of-reflection"><span class="toc_mobile_items-number">1.8.1.</span> <span class="toc_mobile_items-text">Drawbacks of Reflection</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#结语"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">结语</span></a></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#谈一谈java反射-上"><span class="toc-number">1.</span> <span class="toc-text">谈一谈Java反射 (上)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从-getmethod-和-getdeclaredmethod-说起"><span class="toc-number">1.1.</span> <span class="toc-text">从 getMethod 和 getDeclaredMethod 说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继续深入-getmethod0-方法"><span class="toc-number">1.2.</span> <span class="toc-text">继续深入 - getMethod0 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再进一步-getmethodsrecursive-方法"><span class="toc-number">1.3.</span> <span class="toc-text">再进一步 - getMethodsRecursive 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#走到底了-privategetdeclaredmethods-方法"><span class="toc-number">1.4.</span> <span class="toc-text">走到底了 - privateGetDeclaredMethods 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回过头来提一提-searchmethod-方法"><span class="toc-number">1.5.</span> <span class="toc-text">回过头来提一提 - searchMethod 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再来看一看-getreflectionfactorycopymethod-方法"><span class="toc-number">1.6.</span> <span class="toc-text">再来看一看- getReflectionFactory()#copyMethod() 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#methodinvoke-开始了-从方法调用开始"><span class="toc-number">1.7.</span> <span class="toc-text">Method#invoke 开始了, 从方法调用开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step-1-检查调用权限"><span class="toc-number">1.7.1.</span> <span class="toc-text">Step 1. 检查调用权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2获取-methodaccessor-对象"><span class="toc-number">1.7.2.</span> <span class="toc-text">Step 2.获取 MethodAccessor 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用-methodaccessorinvoke-对方法进行调用"><span class="toc-number">1.7.3.</span> <span class="toc-text">调用 MethodAccessor#invoke 对方法进行调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#慢在哪里"><span class="toc-number">1.8.</span> <span class="toc-text">慢在哪里?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#drawbacks-of-reflection"><span class="toc-number">1.8.1.</span> <span class="toc-text">Drawbacks of Reflection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">1.9.</span> <span class="toc-text">结语</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://i.loli.net/2019/10/26/LebU96TKxpA27Ev.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">谈一谈Java反射 (上)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-26<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-10-26</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 28 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="谈一谈java反射-上"><a class="markdownIt-Anchor" href="#谈一谈java反射-上"></a> 谈一谈Java反射 (上)</h1><p>​	小到Minecraft的注解框架, 大到Spring实例化其Beans, 我们难免都会接触到Java一个非常重要的功能 - <strong>反射 ( Reflection )</strong> , 但提到反射, 伴随而来的往往还有三个字 - <strong>效 率 差</strong> 应该在实际开发中避免使用。 那么反射究竟在哪里慢 ?</p><p>​	让我们从最基本的反射开始, 了解反射的调用过程, 再来看Java 7中新加入的 <strong>MethodHandle</strong> 如何提高反射的运行效率。</p><blockquote><p>注意: 本文采用 Oracle JDK 13.01</p></blockquote><h2 id="从-getmethod-和-getdeclaredmethod-说起"><a class="markdownIt-Anchor" href="#从-getmethod-和-getdeclaredmethod-说起"></a> 从 <strong>getMethod</strong> 和 <strong>getDeclaredMethod</strong> 说起</h2><p>​	在使用反射的过程中, 我们往往会用到 <strong>getMethod</strong> 和 <strong>getDeclaredMethod</strong> 这两个方法, 用来获取类中方法的 <strong>Method</strong> 对象</p><p>​	在 <strong>JDK 13</strong> 中, 这两个方法的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">       Objects.requireNonNull(name);</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       Method method = getMethod0(name, parameterTypes);</span><br><span class="line">       <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodToString(name, parameterTypes));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getReflectionFactory().copyMethod(method);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">       Objects.requireNonNull(name);</span><br><span class="line">       SecurityManager sm = System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">           checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), name, parameterTypes);</span><br><span class="line">       <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(methodToString(name, parameterTypes));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> getReflectionFactory().copyMethod(method);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	通过源代码, 我们可以看出, 两种方法的逻辑基本一致, 都是检查方法权限, 通过 <strong>getMethod0</strong> 或者是 <strong>privateGetDeclaredMethods</strong> 获取 <strong>Method</strong> 对象, 然后再返回 <strong>Method</strong> 对象的拷贝</p><p>​	在检查方法权限的部分, 我们可以看出, 在 <strong>getMethod</strong> 方法下, 传入的参数为 <strong>Member.PUBLIC</strong> , 而在 <strong>getDeclaredMethod</strong> 中传入的则是 <strong>Member.DECLARED</strong> , 查阅源代码我们可以知道, 两个量均为定义在 <strong>Member</strong> 接口中的整型常量, 其中 <strong>PUBLIC</strong> 包括该类(或接口)所有的访问权限为 <strong>public</strong> 的方法也包括继承的成员, 而 <strong>DECLARED</strong> 则是该类所有声明的成员, 包括 <strong>public</strong> , <strong>protected</strong> , <strong>private</strong> 的成员, 但不包括继承的成员。具体代码及文档如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Identifies the set of all public members of a class or interface,</span></span><br><span class="line"><span class="comment">     * including inherited members.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Identifies the set of declared members of a class or interface.</span></span><br><span class="line"><span class="comment">     * Inherited members are not included.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DECLARED = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继续深入-getmethod0-方法"><a class="markdownIt-Anchor" href="#继续深入-getmethod0-方法"></a> 继续深入 - <strong>getMethod0</strong> 方法</h2><p>​	以下是 <strong>getMethod0</strong> 的代码, 通过注释我们可以知道, <strong>getMethod0</strong> 的返回值是一个 <strong>root</strong> 的 <strong>Method</strong> 对象, 并且强调这个 <strong>root</strong> 对象不应该暴露到外部, 而应该通过 <strong>ReflectionFactory.copyMethod</strong> 拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a "root" Method object. This Method object must NOT</span></span><br><span class="line">   <span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line">   <span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Method <span class="title">getMethod0</span><span class="params">(String name, Class&lt;?&gt;[] parameterTypes)</span> </span>&#123;</span><br><span class="line">       PublicMethods.MethodList res = getMethodsRecursive(</span><br><span class="line">           name,</span><br><span class="line">           parameterTypes == <span class="keyword">null</span> ? EMPTY_CLASS_ARRAY : parameterTypes,</span><br><span class="line">           <span class="comment">/* includeStatic */</span> <span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">return</span> res == <span class="keyword">null</span> ? <span class="keyword">null</span> : res.getMostSpecific();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	看完注释, 再来看源代码, 这里通过 <strong>getMethodsRecursive</strong> 方法获取到了一个 <strong>MethodList</strong> 对象, 并通过其 <strong>getMostSpecific</strong> 方法, 筛选出最为<strong>明确具体</strong>的方法返回</p><blockquote><p>注: 或者说当一个方法签名子类和父类同时满足要求时, 优先选择子类而不是父类</p></blockquote><h2 id="再进一步-getmethodsrecursive-方法"><a class="markdownIt-Anchor" href="#再进一步-getmethodsrecursive-方法"></a> 再进一步 - <strong>getMethodsRecursive</strong> 方法</h2><p>​	以下为 <strong>getMethodsRecursive</strong> 的源代码, 可以看出注释同样是强调该方法返回的 <strong>root Method</strong> 对象不应该暴露于外部, 而应该通过 <strong>ReflectionFactory.copyMethod</strong> 拷贝</p><p>​	不过有趣的一点是, 在这里我们看到了在 <strong>getDeclaredMethod</strong> 方法中出现的 <strong>privateGetDeclaredMethods</strong> 方法, 不过不同的是, 这里的 <strong>publicOnly</strong> 参数传入的是 <strong>true</strong> 而非 <strong>false</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a list of "root" Method objects. These Method objects must NOT</span></span><br><span class="line">   <span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line">   <span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line">   <span class="keyword">private</span> PublicMethods.<span class="function">MethodList <span class="title">getMethodsRecursive</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        <span class="keyword">boolean</span> includeStatic)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 1st check declared public methods</span></span><br><span class="line">       Method[] methods = privateGetDeclaredMethods(<span class="comment">/* publicOnly */</span> <span class="keyword">true</span>);</span><br><span class="line">       PublicMethods.MethodList res = PublicMethods.MethodList</span><br><span class="line">           .filter(methods, name, parameterTypes, includeStatic);</span><br><span class="line">       <span class="comment">// if there is at least one match among declared methods, we need not</span></span><br><span class="line">       <span class="comment">// search any further as such match surely overrides matching methods</span></span><br><span class="line">       <span class="comment">// declared in superclass(es) or interface(s).</span></span><br><span class="line">       <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if there was no match among declared methods,</span></span><br><span class="line">       <span class="comment">// we must consult the superclass (if any) recursively...</span></span><br><span class="line">       Class&lt;?&gt; sc = getSuperclass();</span><br><span class="line">       <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">           res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ...and coalesce the superclass methods with methods obtained</span></span><br><span class="line">       <span class="comment">// from directly implemented interfaces excluding static methods...</span></span><br><span class="line">       <span class="keyword">for</span> (Class&lt;?&gt; intf : getInterfaces(<span class="comment">/* cloneArray */</span> <span class="keyword">false</span>)) &#123;</span><br><span class="line">           res = PublicMethods.MethodList.merge(</span><br><span class="line">               res, intf.getMethodsRecursive(name, parameterTypes,</span><br><span class="line">                                             <span class="comment">/* includeStatic */</span> <span class="keyword">false</span>));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	通过阅读源代码我们可以发现, 这里获取方法分为三个步骤:</p><ol><li>通过<strong>privateGetDeclaredMethods</strong>获取自己所有的 <strong>public</strong>方法, 并通过<strong>MethodList#filter</strong><br>方法过滤方法, 找出所有满足条件的方法 , 如果至少有一个满足条件的方法, 便不再继续搜索而是直接返回, 因为它肯定 <strong>override</strong> 了父类或者接口的对应方法</li><li>如果没有在自己的方法中找到, 便去递归 搜索父类的的方法</li><li>如果没有在自己的方法中找到, 便去递归搜索自己所有接口的方法</li></ol><p>​	观察上述三个步骤我们可以发现, 最终获取方法, 我们还是要通过 <strong>privateGetDeclaredMethods</strong> 方法, 所以接下来, 让我们去深入了解一下它的实现</p><h2 id="走到底了-privategetdeclaredmethods-方法"><a class="markdownIt-Anchor" href="#走到底了-privategetdeclaredmethods-方法"></a> 走到底了 - <strong>privateGetDeclaredMethods</strong> 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an array of "root" methods. These Method objects must NOT</span></span><br><span class="line">   <span class="comment">// be propagated to the outside world, but must instead be copied</span></span><br><span class="line">   <span class="comment">// via ReflectionFactory.copyMethod.</span></span><br><span class="line">   <span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="keyword">boolean</span> publicOnly) &#123;</span><br><span class="line">       Method[] res;</span><br><span class="line">       ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">       <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">           res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">           <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">       res = Reflection.filterMethods(<span class="keyword">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">       <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">               rd.declaredPublicMethods = res;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               rd.declaredMethods = res;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	终于, 我们来到了 <strong>getMethod</strong> 和 <strong>getDeclaredMethod</strong> 方法的终点, 观察他的方法, 似乎也很简单, 如果存在缓存则直接使用缓存获取 <strong>Method</strong> 对象的数组, 如果不存在缓存,就从 <strong>JVM</strong> 获取并将其存入缓存</p><p>​	那么, 缓存对象的 <strong>ReflectionData<t></t></strong>到底是个什么样的?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Reflection support.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Reflection data caches various derived names and reflective members. Cached</span></span><br><span class="line">   <span class="comment">// values may be invalidated when JVM TI RedefineClasses() is called</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">       <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">       <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Cached names</span></span><br><span class="line">       String simpleName;</span><br><span class="line">       String canonicalName;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> String NULL_SENTINEL = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">       ReflectionData(<span class="keyword">int</span> redefinedCount) &#123;</span><br><span class="line">           <span class="keyword">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	可以看到, <strong>ReflectionData</strong> 类中缓存了<strong>Class</strong>中的所有属性和方法以及构造函数, 甚至是类的 <strong>simpleName</strong> 和 <strong>canonicalName</strong></p><p>​	让我们再来看看 <strong>reflectionData</strong> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazily create and cache ReflectionData</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">reflectionData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">       <span class="keyword">int</span> classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">       ReflectionData&lt;T&gt; rd;</span><br><span class="line">       <span class="keyword">if</span> (reflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (rd = reflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">           <span class="keyword">return</span> rd;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class="line">       <span class="comment">// -&gt; create and replace new instance</span></span><br><span class="line">       <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	在 <strong>Class</strong> 对象中, 存在一个 <strong>ReflectionData</strong> 的软引用作为缓存, 如果缓存为空, 或者软引用已经被GC , 或者缓存已经过期, 就使用 <strong>newReflectionData</strong> 方法重建缓存, 并替换掉旧的缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">newReflectionData</span><span class="params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> classRedefinedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ReflectionData&lt;T&gt; rd = <span class="keyword">new</span> ReflectionData&lt;&gt;(classRedefinedCount);</span><br><span class="line">            <span class="comment">// try to CAS it...</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic.casReflectionData(<span class="keyword">this</span>, oldReflectionData, <span class="keyword">new</span> SoftReference&lt;&gt;(rd))) &#123;</span><br><span class="line">                <span class="keyword">return</span> rd;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry</span></span><br><span class="line">            oldReflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">            classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">            <span class="keyword">if</span> (oldReflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (rd = oldReflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">                <span class="keyword">return</span> rd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​	至此, <strong>getMethod</strong> 部分的代码已经结束</p><h2 id="回过头来提一提-searchmethod-方法"><a class="markdownIt-Anchor" href="#回过头来提一提-searchmethod-方法"></a> 回过头来提一提 - <strong>searchMethod</strong> 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method does not copy the returned Method object!</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">searchMethods</span><span class="params">(Method[] methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Class&lt;?&gt;[] parameterTypes)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       ReflectionFactory fact = getReflectionFactory();</span><br><span class="line">       Method res = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">           <span class="keyword">if</span> (m.getName().equals(name)</span><br><span class="line">               &amp;&amp; arrayContentsEq(parameterTypes,</span><br><span class="line">                                  fact.getExecutableSharedParameterTypes(m))</span><br><span class="line">               &amp;&amp; (res == <span class="keyword">null</span></span><br><span class="line">                   || (res.getReturnType() != m.getReturnType()</span><br><span class="line">                       &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))</span><br><span class="line">               res = m;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	可以看出, 这个方法其实相当简单明了, 判断方法的签名是与给定的相同</p><h2 id="再来看一看-getreflectionfactorycopymethod-方法"><a class="markdownIt-Anchor" href="#再来看一看-getreflectionfactorycopymethod-方法"></a> 再来看一看- <strong>getReflectionFactory()#copyMethod()</strong> 方法</h2><p>​	方法的注释中反复提到, 得到的 <strong>root Method</strong> 对象不能暴露给外界, 而需要通过 ** getReflectionFactory()#copyMethod() ** 方法拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Makes a copy of the passed method. The returned method is a</span></span><br><span class="line"><span class="comment">       "child" of the passed one; see the comments in Method.java for</span></span><br><span class="line"><span class="comment">       details. */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Method <span class="title">copyMethod</span><span class="params">(Method arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> langReflectAccess().copyMethod(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	根据注释,实际上最后调用的是<strong>Method#copy</strong>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">   * Package-<span class="function"><span class="keyword">private</span> <span class="title">routine</span> <span class="params">(exposed to java.lang.Class via</span></span></span><br><span class="line"><span class="function"><span class="params">   * ReflectAccess)</span> which returns a copy of <span class="keyword">this</span> Method. The copy's</span></span><br><span class="line"><span class="function">   * "root" field points to <span class="keyword">this</span> Method.</span></span><br><span class="line"><span class="function">   */</span></span><br><span class="line"><span class="function">  Method <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// This routine enables sharing of MethodAccessor objects</span></span><br><span class="line">      <span class="comment">// among Method objects which refer to the same underlying</span></span><br><span class="line">      <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">      <span class="comment">// because of the "accessibility" bit in AccessibleObject,</span></span><br><span class="line">      <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">      <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">      <span class="comment">// objects.)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not copy a non-root Method"</span>);</span><br><span class="line"></span><br><span class="line">      Method res = <span class="keyword">new</span> Method(clazz, name, parameterTypes, returnType,</span><br><span class="line">                              exceptionTypes, modifiers, slot, signature,</span><br><span class="line">                              annotations, parameterAnnotations, annotationDefault);</span><br><span class="line">      res.root = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">      res.methodAccessor = methodAccessor;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​	可以看出, 该方法只能拷贝 <strong>root Method</strong> 对象, 并且在实例化了拷贝后的 <strong>Method</strong> 对象后, 将其 <strong>root</strong> 属性设置为当前的 <strong>root Method</strong> 对象</p><p>​	同时, 根据注释以及源代码, 所有的指向同一个底层方法的 <strong>Method</strong> 对象都会共用一个 <strong>MethodAcessor</strong> 对象,</p><p>​	到这里看起来, 似乎在Java反射的获取 <strong>Method</strong> 对象环节并没有什么特别明显的效率开销的问题, 那么, 接下来我们再来看看, 方法是怎样被 <strong>invoke</strong> 的</p><h2 id="methodinvoke-开始了-从方法调用开始"><a class="markdownIt-Anchor" href="#methodinvoke-开始了-从方法调用开始"></a> <strong>Method#invoke</strong> 开始了, 从方法调用开始</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invokes the underlying method represented by this &#123;<span class="doctag">@code</span> Method&#125;</span></span><br><span class="line"><span class="comment">   * object, on the specified object with the specified parameters.</span></span><br><span class="line"><span class="comment">   * Individual parameters are automatically unwrapped to match</span></span><br><span class="line"><span class="comment">   * primitive formal parameters, and both primitive and reference</span></span><br><span class="line"><span class="comment">   * parameters are subject to method invocation conversions as</span></span><br><span class="line"><span class="comment">   * necessary.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the underlying method is static, then the specified &#123;<span class="doctag">@code</span> obj&#125;</span></span><br><span class="line"><span class="comment">   * argument is ignored. It may be null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the number of formal parameters required by the underlying method is</span></span><br><span class="line"><span class="comment">   * 0, the supplied &#123;<span class="doctag">@code</span> args&#125; array may be of length 0 or null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the underlying method is an instance method, it is invoked</span></span><br><span class="line"><span class="comment">   * using dynamic method lookup as documented in The Java Language</span></span><br><span class="line"><span class="comment">   * Specification, section 15.12.4.4; in particular,</span></span><br><span class="line"><span class="comment">   * overriding based on the runtime type of the target object may occur.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the underlying method is static, the class that declared</span></span><br><span class="line"><span class="comment">   * the method is initialized if it has not already been initialized.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;If the method completes normally, the value it returns is</span></span><br><span class="line"><span class="comment">   * returned to the caller of invoke; if the value has a primitive</span></span><br><span class="line"><span class="comment">   * type, it is first appropriately wrapped in an object. However,</span></span><br><span class="line"><span class="comment">   * if the value has the type of an array of a primitive type, the</span></span><br><span class="line"><span class="comment">   * elements of the array are &lt;i&gt;not&lt;/i&gt; wrapped in objects; in</span></span><br><span class="line"><span class="comment">   * other words, an array of primitive type is returned.  If the</span></span><br><span class="line"><span class="comment">   * underlying method return type is void, the invocation returns</span></span><br><span class="line"><span class="comment">   * null.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> obj  the object the underlying method is invoked from</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args the arguments used for the method call</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the result of dispatching the method represented by</span></span><br><span class="line"><span class="comment">   * this object on &#123;<span class="doctag">@code</span> obj&#125; with parameters</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> args&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span> IllegalAccessException    if this &#123;<span class="doctag">@code</span> Method&#125; object</span></span><br><span class="line"><span class="comment">   *              is enforcing Java language access control and the underlying</span></span><br><span class="line"><span class="comment">   *              method is inaccessible.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span> IllegalArgumentException  if the method is an</span></span><br><span class="line"><span class="comment">   *              instance method and the specified object argument</span></span><br><span class="line"><span class="comment">   *              is not an instance of the class or interface</span></span><br><span class="line"><span class="comment">   *              declaring the underlying method (or of a subclass</span></span><br><span class="line"><span class="comment">   *              or implementor thereof); if the number of actual</span></span><br><span class="line"><span class="comment">   *              and formal parameters differ; if an unwrapping</span></span><br><span class="line"><span class="comment">   *              conversion for primitive arguments fails; or if,</span></span><br><span class="line"><span class="comment">   *              after possible unwrapping, a parameter value</span></span><br><span class="line"><span class="comment">   *              cannot be converted to the corresponding formal</span></span><br><span class="line"><span class="comment">   *              parameter type by a method invocation conversion.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span> InvocationTargetException if the underlying method</span></span><br><span class="line"><span class="comment">   *              throws an exception.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span> NullPointerException      if the specified object is null</span></span><br><span class="line"><span class="comment">   *              and the method is an instance method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@exception</span> ExceptionInInitializerError if the initialization</span></span><br><span class="line"><span class="comment">   * provoked by this method fails.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="meta">@ForceInline</span> <span class="comment">// to ensure Reflection.getCallerClass optimization</span></span><br><span class="line">  <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">         InvocationTargetException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">          Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">          checkAccess(caller, clazz,</span><br><span class="line">                      Modifier.isStatic(modifiers) ? <span class="keyword">null</span> : obj.getClass(),</span><br><span class="line">                      modifiers);</span><br><span class="line">      &#125;</span><br><span class="line">      MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">      <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ma = acquireMethodAccessor();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​	可以看到, <strong>invoke</strong> 方法的实现分为上个步骤</p><ol><li><p>检查是否有调用权限</p></li><li><p>获取 <strong>MethodAccessor</strong> 对象</p></li><li><p>调用 <strong>MethodAccessor#invoke</strong> 对方法进行调用</p><h3 id="step-1-检查调用权限"><a class="markdownIt-Anchor" href="#step-1-检查调用权限"></a> Step 1. 检查调用权限</h3><p>​	如果<strong>override</strong> 属性为<strong>true</strong> 则跳过检查, 即调用<strong>Method#setAccessible(true)</strong> 为设置 <strong>override</strong> 属性为 <strong>true</strong></p><h3 id="step-2获取-methodaccessor-对象"><a class="markdownIt-Anchor" href="#step-2获取-methodaccessor-对象"></a> Step 2.获取 <strong>MethodAccessor</strong> 对象</h3><p>​	获取方法的 <strong>MethodAccessor</strong> 如果为空, 则调用 <strong>acquireMethodAccessor</strong> 方法获取 <strong>MethodAccessor</strong></p><p>​	<strong>acquireMethodAccessor</strong> 方法的源代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOTE that there is no synchronization used here. It is correct</span></span><br><span class="line">   <span class="comment">// (though not efficient) to generate more than one MethodAccessor</span></span><br><span class="line">   <span class="comment">// for a given Method. However, avoiding synchronization will</span></span><br><span class="line">   <span class="comment">// probably make the implementation more scalable.</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> MethodAccessor <span class="title">acquireMethodAccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// First check to see if one has been created yet, and take it</span></span><br><span class="line">       <span class="comment">// if so</span></span><br><span class="line">       MethodAccessor tmp = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (root != <span class="keyword">null</span>) tmp = root.getMethodAccessor();</span><br><span class="line">       <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">           methodAccessor = tmp;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Otherwise fabricate one and propagate it up to the root</span></span><br><span class="line">           tmp = reflectionFactory.newMethodAccessor(<span class="keyword">this</span>);</span><br><span class="line">           setMethodAccessor(tmp);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​	可以看到, 这里的方法并没有 <strong>同步化 ( synchronization )</strong> , 注释也解释说, 为给定的方法,生成多于一个的 <strong>MethodAccessor</strong> 对象是没有问题的, 尽管它可能会不够高效, 但避免同步化, 也使得这个实现更加灵活</p><p>​	通过源代码我们可以看到, 他会尝试先获取 <strong>root Method</strong> 对象的 <strong>MethodAccessor</strong> 对象, 如果其为空, 则通过 <strong>ReflectionFactory#newMethodAccessor</strong> 方法新建一个 <strong>MethodAccessor</strong> 对象, 并将其设置为当前 <strong>Method</strong> 的 <strong>MethodAccessor</strong></p><p>​	下面是 <strong>ReflectionFactory#newMethodAccessor</strong> 的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        checkInitted();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Reflection.isCallerSensitive(method)) &#123;</span><br><span class="line">            Method altMethod = findMethodForReflection(method);</span><br><span class="line">            <span class="keyword">if</span> (altMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                method = altMethod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use the root Method that will not cache caller class</span></span><br><span class="line">        Method root = langReflectAccess().getRoot(method);</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                generateMethod(method.getDeclaringClass(),</span><br><span class="line">                               method.getName(),</span><br><span class="line">                               method.getParameterTypes(),</span><br><span class="line">                               method.getReturnType(),</span><br><span class="line">                               method.getExceptionTypes(),</span><br><span class="line">                               method.getModifiers());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            NativeMethodAccessorImpl acc =</span><br><span class="line">                <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">            DelegatingMethodAccessorImpl res =</span><br><span class="line">                <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">            acc.setParent(res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​	我们可以看到, 该方法会先调用 <strong>ReflectionFactory#checkInitted</strong> 方法, 检查 <strong>java.lang.reflect.Method</strong> 的 <strong>static initializer</strong> 是否已经完成初始化</p><p>​	以下是 <strong>ReflectionFactory#checkInitted</strong> 方法的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** We have to defer full initialization of this class until after</span></span><br><span class="line"><span class="comment">      the static initializer is run since java.lang.reflect.Method's</span></span><br><span class="line"><span class="comment">      static initializer (more properly, that for</span></span><br><span class="line"><span class="comment">      java.lang.reflect.AccessibleObject) causes this class's to be</span></span><br><span class="line"><span class="comment">      run, before the system properties are set up. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (initted) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// Defer initialization until module system is initialized so as</span></span><br><span class="line">      <span class="comment">// to avoid inflation and spinning bytecode in unnamed modules</span></span><br><span class="line">      <span class="comment">// during early startup.</span></span><br><span class="line">      <span class="keyword">if</span> (!VM.isModuleSystemInited()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      Properties props = GetPropertyAction.privilegedGetProperties();</span><br><span class="line">      String val = props.getProperty(<span class="string">"sun.reflect.noInflation"</span>);</span><br><span class="line">      <span class="keyword">if</span> (val != <span class="keyword">null</span> &amp;&amp; val.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">          noInflation = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      val = props.getProperty(<span class="string">"sun.reflect.inflationThreshold"</span>);</span><br><span class="line">      <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              inflationThreshold = Integer.parseInt(val);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to parse property sun.reflect.inflationThreshold"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      disableSerialConstructorChecks =</span><br><span class="line">          <span class="string">"true"</span>.equals(props.getProperty(<span class="string">"jdk.disableSerialConstructorChecks"</span>));</span><br><span class="line">   </span><br><span class="line">      initted = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​	可以看到, 其中设置了在 ** ReflectionFactory#newMethodAccessor ** 方法中使用到的 <strong>noInflation</strong> 属性</p><p>​	对于 <strong>sun.reflect.noInflation</strong> 属性, Oracle的Blog上是这么解释的</p><blockquote><p><strong>sun.reflect.noInflation</strong></p><p>This boolean will disable inflation (the default use of JNI before the threshold is reached). In other words, if this is set to true, we immediately skip to generating a pure-Java implementation on the first access. (default: false)</p></blockquote><p>​	从代码中我们可以看到, 当 <strong>noInflation</strong> 属性直接设置为 <strong>true</strong> 会直接采用纯Java版本的<strong>MethodAcessorImpl</strong> 即 <strong>MagicAccessorImpl</strong> , 去生成 <strong>Java Bytecode</strong></p><p>​	默认情况下我们会采用 <strong>NativeMethodAcessorImpl</strong> 以及采用 <strong>DelegatingMethodAccessorImpl</strong> 做代理的方式实现</p><p>​	以下是 <strong>NativeMethodAcessorImpl</strong> 以及 <strong>DelegatingMethodAccessorImpl</strong> 的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Used only for the first few invocations of a Method; afterward,</span></span><br><span class="line"><span class="comment">    switches to bytecode-based implementation */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates its invocation to another MethodAccessorImpl and can</span></span><br><span class="line"><span class="comment">    change its delegate at run time. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123;</span><br><span class="line">        setDelegate(delegate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​	通过 <strong>NativeMethodAccessorImpl</strong> 的源代码和注释我们可以知道, ** NativeMethodAccessorImpl** 仅仅只被用于低于 <strong>inflationThreshold</strong> 次的调用, 其内部维护了一个 <strong>numInvocations</strong> 的变量作为计数器, 当超过阈值时, 会采用 **<strong>MagicAccessorImpl</strong> 生成 <strong>Java Bytecode</strong></p><p>​	该阈值为 ** sun.reflect.inflationThreshold** 属性</p><blockquote><p><strong>sun.reflect.inflationThreshold</strong></p><p>This integer specifies the number of times a method will be accessed via the JNI implementation before a custom pure-Java accessor is generated. (default: 15)</p></blockquote><p>​	这也是为什么会使用 <strong>DelegatingMethodAccessorImpl</strong> 作为代理</p><p>​	根据注释</p><blockquote><p>**“Inflation” mechanism. **</p><p>​	Loading bytecodes to implement<br>​ Method.invoke() and Constructor.newInstance() currently costs<br>​ 3-4x more than an invocation via native code for the first<br>​ invocation (though subsequent invocations have been benchmarked<br>​ to be over 20x faster). Unfortunately this cost increases<br>​ startup time for certain applications that use reflection<br>​ intensively (but only once per class) to bootstrap themselves.<br>​ To avoid this penalty we reuse the existing JVM entry points<br>​ for the first few invocations of Methods and Constructors and<br>​ then switch to the bytecode-based implementations.</p></blockquote><p>​	Java版本的<strong>MagicAcessorImpl</strong> 的调用效率是 <strong>NativeMethodAcessorImpl</strong> 的 20 倍以上, 但初次调用生成的是否会比 <strong>Native</strong> 版本的慢 3 - 4倍, 这带来了更长的启动时间</p><p>​	这也是为什么 Java 反射会采用这种策略</p></li></ol><h3 id="调用-methodaccessorinvoke-对方法进行调用"><a class="markdownIt-Anchor" href="#调用-methodaccessorinvoke-对方法进行调用"></a> 调用 <strong>MethodAccessor#invoke</strong> 对方法进行调用</h3><p>​	在我们得到了 <strong>MethodAccessor</strong> 对象后, 就可以通过其 <strong>invoke</strong> 方法实现最终的调用操作</p><p>​	<strong>NativeMethodAccessorImpl</strong> 的 <strong>invoke</strong> 方法为一个计数器加调用一个名为 <strong>invoke0</strong> 的 <strong>native</strong> 方法</p><p>​	即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​	<strong>DelegatingMethodAccessorImpl</strong> 的 <strong>invoke</strong> 方法更不用说, 直接调用代理对象的 <strong>invoke</strong> 方法</p><p>​	即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delegate.invoke(obj, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​	而 <strong>MagicAcessorImpl</strong> 通过 <strong>MethodAccessorGenerator#generate</strong> 方法生成字节码之后, 会调用<strong>MethodAcessorGenerator#emitInvoke</strong> 方法, 为<strong>invoke</strong> 和 <strong>newInstance</strong> 方法生成实际的调用</p><p>​	其源代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This emits the code for either invoke() or newInstance() */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emitInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOTE that this code will only handle 65535 parameters since we</span></span><br><span class="line">    <span class="comment">// use the sipush instruction to get the array index on the</span></span><br><span class="line">    <span class="comment">// operand stack.</span></span><br><span class="line">    <span class="keyword">if</span> (parameterTypes.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Can't handle more than 65535 parameters"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate code into fresh code buffer</span></span><br><span class="line">    ClassFileAssembler cb = <span class="keyword">new</span> ClassFileAssembler();</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        <span class="comment">// 1 incoming argument</span></span><br><span class="line">        cb.setMaxLocals(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2 incoming arguments</span></span><br><span class="line">        cb.setMaxLocals(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> illegalArgStartPC = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        <span class="comment">// Instantiate target class before continuing</span></span><br><span class="line">        <span class="comment">// new &lt;target class type&gt;</span></span><br><span class="line">        <span class="comment">// dup</span></span><br><span class="line">        cb.opc_new(targetClass);</span><br><span class="line">        cb.opc_dup();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Get target object on operand stack if necessary.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to do an explicit null check here; we won't see</span></span><br><span class="line">        <span class="comment">// NullPointerExceptions from the invoke bytecode, since it's</span></span><br><span class="line">        <span class="comment">// covered by an exception handler.</span></span><br><span class="line">        <span class="keyword">if</span> (!isStatic()) &#123;</span><br><span class="line">            <span class="comment">// aload_1</span></span><br><span class="line">            <span class="comment">// ifnonnull &lt;checkcast label&gt;</span></span><br><span class="line">            <span class="comment">// new &lt;NullPointerException&gt;</span></span><br><span class="line">            <span class="comment">// dup</span></span><br><span class="line">            <span class="comment">// invokespecial &lt;NullPointerException ctor&gt;</span></span><br><span class="line">            <span class="comment">// athrow</span></span><br><span class="line">            <span class="comment">// &lt;checkcast label:&gt;</span></span><br><span class="line">            <span class="comment">// aload_1</span></span><br><span class="line">            <span class="comment">// checkcast &lt;target class's type&gt;</span></span><br><span class="line">            cb.opc_aload_1();</span><br><span class="line">            Label l = <span class="keyword">new</span> Label();</span><br><span class="line">            cb.opc_ifnonnull(l);</span><br><span class="line">            cb.opc_new(nullPointerClass);</span><br><span class="line">            cb.opc_dup();</span><br><span class="line">            cb.opc_invokespecial(nullPointerCtorIdx, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            cb.opc_athrow();</span><br><span class="line">            l.bind();</span><br><span class="line">            illegalArgStartPC = cb.getLength();</span><br><span class="line">            cb.opc_aload_1();</span><br><span class="line">            cb.opc_checkcast(targetClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Have to check length of incoming array and throw</span></span><br><span class="line">    <span class="comment">// IllegalArgumentException if not correct. A concession to the</span></span><br><span class="line">    <span class="comment">// JCK (isn't clearly specified in the spec): we allow null in the</span></span><br><span class="line">    <span class="comment">// case where the argument list is zero length.</span></span><br><span class="line">    <span class="comment">// if no-arg:</span></span><br><span class="line">    <span class="comment">//   aload_2 | aload_1 (Method | Constructor)</span></span><br><span class="line">    <span class="comment">//   ifnull &lt;success label&gt;</span></span><br><span class="line">    <span class="comment">// aload_2 | aload_1</span></span><br><span class="line">    <span class="comment">// arraylength</span></span><br><span class="line">    <span class="comment">// sipush &lt;num parameter types&gt;</span></span><br><span class="line">    <span class="comment">// if_icmpeq &lt;success label&gt;</span></span><br><span class="line">    <span class="comment">// new &lt;IllegalArgumentException&gt;</span></span><br><span class="line">    <span class="comment">// dup</span></span><br><span class="line">    <span class="comment">// invokespecial &lt;IllegalArgumentException ctor&gt;</span></span><br><span class="line">    <span class="comment">// athrow</span></span><br><span class="line">    <span class="comment">// &lt;success label:&gt;</span></span><br><span class="line">    Label successLabel = <span class="keyword">new</span> Label();</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">            cb.opc_aload_1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cb.opc_aload_2();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.opc_ifnull(successLabel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        cb.opc_aload_1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.opc_aload_2();</span><br><span class="line">    &#125;</span><br><span class="line">    cb.opc_arraylength();</span><br><span class="line">    cb.opc_sipush((<span class="keyword">short</span>) parameterTypes.length);</span><br><span class="line">    cb.opc_if_icmpeq(successLabel);</span><br><span class="line">    cb.opc_new(illegalArgumentClass);</span><br><span class="line">    cb.opc_dup();</span><br><span class="line">    cb.opc_invokespecial(illegalArgumentCtorIdx, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    cb.opc_athrow();</span><br><span class="line">    successLabel.bind();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through incoming actual parameters, ensuring that each</span></span><br><span class="line">    <span class="comment">// is compatible with the formal parameter type, and pushing the</span></span><br><span class="line">    <span class="comment">// actual on the operand stack (unboxing and widening if necessary).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> paramTypeCPIdx = nonPrimitiveParametersBaseIdx;</span><br><span class="line">    Label nextParamLabel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span> count = <span class="number">1</span>; <span class="comment">// both invokeinterface opcode's "count" as well as</span></span><br><span class="line">    <span class="comment">// num args of other invoke bytecodes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">        Class&lt;?&gt; paramType = parameterTypes[i];</span><br><span class="line">        count += (<span class="keyword">byte</span>) typeSizeInStackSlots(paramType);</span><br><span class="line">        <span class="keyword">if</span> (nextParamLabel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextParamLabel.bind();</span><br><span class="line">            nextParamLabel = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// aload_2 | aload_1</span></span><br><span class="line">        <span class="comment">// sipush &lt;index&gt;</span></span><br><span class="line">        <span class="comment">// aaload</span></span><br><span class="line">        <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">            cb.opc_aload_1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cb.opc_aload_2();</span><br><span class="line">        &#125;</span><br><span class="line">        cb.opc_sipush((<span class="keyword">short</span>) i);</span><br><span class="line">        cb.opc_aaload();</span><br><span class="line">        <span class="keyword">if</span> (isPrimitive(paramType)) &#123;</span><br><span class="line">            <span class="comment">// Unboxing code.</span></span><br><span class="line">            <span class="comment">// Put parameter into temporary local variable</span></span><br><span class="line">            <span class="comment">// astore_3 | astore_2</span></span><br><span class="line">            <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">                cb.opc_astore_2();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cb.opc_astore_3();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// repeat for all possible widening conversions:</span></span><br><span class="line">            <span class="comment">//   aload_3 | aload_2</span></span><br><span class="line">            <span class="comment">//   instanceof &lt;primitive boxing type&gt;</span></span><br><span class="line">            <span class="comment">//   ifeq &lt;next unboxing label&gt;</span></span><br><span class="line">            <span class="comment">//   aload_3 | aload_2</span></span><br><span class="line">            <span class="comment">//   checkcast &lt;primitive boxing type&gt; // Note: this is "redundant",</span></span><br><span class="line">            <span class="comment">//                                     // but necessary for the verifier</span></span><br><span class="line">            <span class="comment">//   invokevirtual &lt;unboxing method&gt;</span></span><br><span class="line">            <span class="comment">//   &lt;widening conversion bytecode, if necessary&gt;</span></span><br><span class="line">            <span class="comment">//   goto &lt;next parameter label&gt;</span></span><br><span class="line">            <span class="comment">// &lt;next unboxing label:&gt; ...</span></span><br><span class="line">            <span class="comment">// last unboxing label:</span></span><br><span class="line">            <span class="comment">//   new &lt;IllegalArgumentException&gt;</span></span><br><span class="line">            <span class="comment">//   dup</span></span><br><span class="line">            <span class="comment">//   invokespecial &lt;IllegalArgumentException ctor&gt;</span></span><br><span class="line">            <span class="comment">//   athrow</span></span><br><span class="line"></span><br><span class="line">            Label l = <span class="keyword">null</span>; <span class="comment">// unboxing label</span></span><br><span class="line">            nextParamLabel = <span class="keyword">new</span> Label();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; primitiveTypes.length; j++) &#123;</span><br><span class="line">                Class&lt;?&gt; c = primitiveTypes[j];</span><br><span class="line">                <span class="keyword">if</span> (canWidenTo(c, paramType)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        l.bind();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Emit checking and unboxing code for this type</span></span><br><span class="line">                    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">                        cb.opc_aload_2();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.opc_aload_3();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cb.opc_instanceof(indexForPrimitiveType(c));</span><br><span class="line">                    l = <span class="keyword">new</span> Label();</span><br><span class="line">                    cb.opc_ifeq(l);</span><br><span class="line">                    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">                        cb.opc_aload_2();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cb.opc_aload_3();</span><br><span class="line">                    &#125;</span><br><span class="line">                    cb.opc_checkcast(indexForPrimitiveType(c));</span><br><span class="line">                    cb.opc_invokevirtual(unboxingMethodForPrimitiveType(c),</span><br><span class="line">                                         <span class="number">0</span>,</span><br><span class="line">                                         typeSizeInStackSlots(c));</span><br><span class="line">                    emitWideningBytecodeForPrimitiveConversion(cb,</span><br><span class="line">                                                               c,</span><br><span class="line">                                                               paramType);</span><br><span class="line">                    cb.opc_goto(nextParamLabel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError</span><br><span class="line">                    (<span class="string">"Must have found at least identity conversion"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fell through; given object is null or invalid. According to</span></span><br><span class="line">            <span class="comment">// the spec, we can throw IllegalArgumentException for both of</span></span><br><span class="line">            <span class="comment">// these cases.</span></span><br><span class="line"></span><br><span class="line">            l.bind();</span><br><span class="line">            cb.opc_new(illegalArgumentClass);</span><br><span class="line">            cb.opc_dup();</span><br><span class="line">            cb.opc_invokespecial(illegalArgumentCtorIdx, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            cb.opc_athrow();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Emit appropriate checkcast</span></span><br><span class="line">            cb.opc_checkcast(paramTypeCPIdx);</span><br><span class="line">            paramTypeCPIdx = add(paramTypeCPIdx, S2);</span><br><span class="line">            <span class="comment">// Fall through to next argument</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bind last goto if present</span></span><br><span class="line">    <span class="keyword">if</span> (nextParamLabel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nextParamLabel.bind();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> invokeStartPC = cb.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OK, ready to perform the invocation.</span></span><br><span class="line">    <span class="keyword">if</span> (isConstructor) &#123;</span><br><span class="line">        cb.opc_invokespecial(targetMethodRef, count, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isStatic()) &#123;</span><br><span class="line">            cb.opc_invokestatic(targetMethodRef,</span><br><span class="line">                                count,</span><br><span class="line">                                typeSizeInStackSlots(returnType));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isInterface()) &#123;</span><br><span class="line">                cb.opc_invokeinterface(targetMethodRef,</span><br><span class="line">                                       count,</span><br><span class="line">                                       count,</span><br><span class="line">                                       typeSizeInStackSlots(returnType));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cb.opc_invokevirtual(targetMethodRef,</span><br><span class="line">                                     count,</span><br><span class="line">                                     typeSizeInStackSlots(returnType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> invokeEndPC = cb.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isConstructor) &#123;</span><br><span class="line">        <span class="comment">// Box return value if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (isPrimitive(returnType)) &#123;</span><br><span class="line">            cb.opc_invokestatic(boxingMethodForPrimitiveType(returnType),</span><br><span class="line">                                typeSizeInStackSlots(returnType),</span><br><span class="line">                                <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnType == Void.TYPE) &#123;</span><br><span class="line">            cb.opc_aconst_null();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cb.opc_areturn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We generate two exception handlers; one which is responsible</span></span><br><span class="line">    <span class="comment">// for catching ClassCastException and NullPointerException and</span></span><br><span class="line">    <span class="comment">// throwing IllegalArgumentException, and the other which catches</span></span><br><span class="line">    <span class="comment">// all java/lang/Throwable objects thrown from the target method</span></span><br><span class="line">    <span class="comment">// and wraps them in InvocationTargetExceptions.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> classCastHandler = cb.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ClassCast, etc. exception handler</span></span><br><span class="line">    cb.setStack(<span class="number">1</span>);</span><br><span class="line">    cb.opc_invokespecial(toStringIdx, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    cb.opc_new(illegalArgumentClass);</span><br><span class="line">    cb.opc_dup_x1();</span><br><span class="line">    cb.opc_swap();</span><br><span class="line">    cb.opc_invokespecial(illegalArgumentStringCtorIdx, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cb.opc_athrow();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> invocationTargetHandler = cb.getLength();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// InvocationTargetException exception handler</span></span><br><span class="line">    cb.setStack(<span class="number">1</span>);</span><br><span class="line">    cb.opc_new(invocationTargetClass);</span><br><span class="line">    cb.opc_dup_x1();</span><br><span class="line">    cb.opc_swap();</span><br><span class="line">    cb.opc_invokespecial(invocationTargetCtorIdx, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cb.opc_athrow();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate exception table. We cover the entire code sequence</span></span><br><span class="line">    <span class="comment">// with an exception handler which catches ClassCastException and</span></span><br><span class="line">    <span class="comment">// converts it into an IllegalArgumentException.</span></span><br><span class="line"></span><br><span class="line">    ClassFileAssembler exc = <span class="keyword">new</span> ClassFileAssembler();</span><br><span class="line"></span><br><span class="line">    exc.emitShort(illegalArgStartPC);       <span class="comment">// start PC</span></span><br><span class="line">    exc.emitShort(invokeStartPC);           <span class="comment">// end PC</span></span><br><span class="line">    exc.emitShort(classCastHandler);        <span class="comment">// handler PC</span></span><br><span class="line">    exc.emitShort(classCastClass);          <span class="comment">// catch type</span></span><br><span class="line"></span><br><span class="line">    exc.emitShort(illegalArgStartPC);       <span class="comment">// start PC</span></span><br><span class="line">    exc.emitShort(invokeStartPC);           <span class="comment">// end PC</span></span><br><span class="line">    exc.emitShort(classCastHandler);        <span class="comment">// handler PC</span></span><br><span class="line">    exc.emitShort(nullPointerClass);        <span class="comment">// catch type</span></span><br><span class="line"></span><br><span class="line">    exc.emitShort(invokeStartPC);           <span class="comment">// start PC</span></span><br><span class="line">    exc.emitShort(invokeEndPC);             <span class="comment">// end PC</span></span><br><span class="line">    exc.emitShort(invocationTargetHandler); <span class="comment">// handler PC</span></span><br><span class="line">    exc.emitShort(throwableClass);          <span class="comment">// catch type</span></span><br><span class="line"></span><br><span class="line">    emitMethod(invokeIdx, cb.getMaxLocals(), cb, exc,</span><br><span class="line">               <span class="keyword">new</span> <span class="keyword">short</span>[] &#123; invocationTargetClass &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>通过这段代码的注释, 我们可以发现, 生成的 **invoke** 方法对传入的参数进行了校验工作, 并尝试了所有可能的扩展操作
</code></pre><p>​	至此, Java反射的流程已经介绍完毕</p><h2 id="慢在哪里"><a class="markdownIt-Anchor" href="#慢在哪里"></a> 慢在哪里?</h2><ol><li><p>反射需要查找类的方法表, 需要对方法进行遍历操作</p></li><li><p>反射调用时, <strong>Method#invoke</strong> 方法和 <strong>emitInvoke</strong> 方法会对传入的参数进行校验, 其中会进行 <strong>boxing</strong> 和 <strong>unboxing</strong> 操作</p></li><li><p>每次反射调用都需要校验方法的可见性</p></li><li><p>反射调用方法难以被JIT优化, 难以被内联操作</p><p>即Oracle的文档中提到的</p><h3 id="drawbacks-of-reflection"><a class="markdownIt-Anchor" href="#drawbacks-of-reflection"></a> Drawbacks of Reflection</h3><blockquote><p>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</p><ul><li><p><strong>Performance Overhead</strong></p><p>Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</p></li><li><p><strong>Security Restrictions</strong></p><p>Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</p></li><li><p><strong>Exposure of Internals</strong></p><p>Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing <strong>private</strong> fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</p></li></ul></blockquote></li></ol><h2 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h2><p>​	本篇文章, 从 <strong>getMethod</strong> 方法说起到 <strong>invoke</strong> 过了一遍 Java 的方法调用反射, 简单分析了 传统的反射为什么效率低下</p><p>​	而下一篇文章, 将介绍于 JDK7 引入的 <strong>MethodHandle</strong> , 并介绍其如何优化反射调用</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Twiliness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://twiliness.xyz/2019/10/26/Java-Reflection-01/">https://twiliness.xyz/2019/10/26/Java-Reflection-01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://twiliness.xyz">Twilight Spring</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java </a><a class="post-meta__tags" href="/tags/Reflection-反射/">Reflection ( 反射 )</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/10/26/LebU96TKxpA27Ev.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/26/Java-Reflection-02/"><img class="prev_cover lozad" data-src="https://i.loli.net/2019/10/26/dIuON6B7hUtfs2m.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="label">上一篇</div><div class="prev_info"><span>谈一谈Java反射 (下)</span></div></a></div><div class="next-post pull-right"><a href="/2019/10/07/String-Matching-03-KMP/"><img class="next_cover lozad" data-src="https://i.loli.net/2019/10/07/R2mAf9kEt5CyVIw.jpg" onerror='onerror=null,src="/img/404.jpg"'><div class="label">下一篇</div><div class="next_info"><span>字符串匹配03 - KMP 算法</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/26/Java-Reflection-02/" title="谈一谈Java反射 (下)"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/10/26/dIuON6B7hUtfs2m.jpg"><div class="relatedPosts_title">谈一谈Java反射 (下)</div></a></div><div class="relatedPosts_item"><a href="/2019/10/26/Java-Synchronizers/" title="Java-Synchronizers"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/10/26/WMZOPqULI7NuVvY.jpg"><div class="relatedPosts_title">Java-Synchronizers</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2019 - 2020 By Twiliness</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function(){$("span.katex-display").wrap('<div class="katex-wrap"></div>')})</script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script src="/js/tw_cn.js"></script><script>translateInitilization()</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script></body></html>